function fn(){
    console.log('12');
    Promise.resolve().then(fn)
}
fn();
// 微任务包括Promise的回调函数、MutationObserver的回调函数等，它们在当前任务执行完毕后立即执行。
// 也就是说，如果一个微任务在执行过程中又产生了新的微任务，那么新的微任务会被立即添加到微任务队列中，并在当前微任务执行完毕后立即执行。这就可能导致微任务队列中的任务不断增加，从而导致内存溢出。


function fn2(){
    console.log('2');
    setTimeout(fn2, 0)
}
fn2();

// 这种写法不会导致内存溢出，如果一个宏任务在执行过程中又产生了新的宏任务，那么新的宏任务会被添加到下一轮事件循环中执行，而不是立即执行。
// 这就保证了宏任务队列中的任务数量不会无限增加，从而避免了内存溢出
