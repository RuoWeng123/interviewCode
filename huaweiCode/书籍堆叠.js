/*书籍的长宽都是整数对应(l,w)，如果书A的长宽度都比B长宽大时，则允许将B排列放在A上面。

现在有一组规格的书籍，书籍叠放时要求书籍不能做旋转，请计算最多有多少个规格书籍能叠放在一起。

输入描述
输入一个数组books，每个元素表示书籍的长宽，例如：[20,16],[15,11],[10,10],[9,10]。

总共有4本书，第一本长度为20宽度为16，第二本长度为15宽度为11，以此类推，最后一本书长度为9宽度为10。

输出描述
最多可以叠放在一起的规格书籍的数量，输出：3。

最多三个规格的书籍可以叠放在一起，从下到上依次是[20,16],[15,11],[10,10]。*/
function solveMethod(n, e, steps) {
  // 转变成字典表，便于查找
  const dictSteps = new Map(steps);
  // 每一步的位移，初始为0
  let offset = 0;
  // 总面积
  let area = 0;
  
  // 遍历起点到终点的长度e，如果该点在steps中能找到且做了位移，则进行改变
  for (let i = 0; i < e; i++) {
    if (dictSteps.has(i)) {
      // 更新位移
      offset += dictSteps.get(i);
    }
    // 面积即位移大小，向终点走的每一步都要累加计算
    area += Math.abs(offset);
  }
  
  return area;
}

// 示例用法
console.log(solveMethod(4, 10, [[1, 1], [2, 1], [3, 1], [4, -2]])); // 输出 12
console.log(solveMethod(2, 4, [[0, 1], [2, -2]])); // 输出 4
